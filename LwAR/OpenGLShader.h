#pragma once


#pragma region Standard Shader

static const char standardShaderVert[] =
"#version 330 core\n"
"\n"
"// Input vertex data, different for all executions of this shader.\n"
"layout(location = 0) in vec3 vertexPosition_modelspace;\n"
"layout(location = 1) in vec2 vertexUV;\n"
"layout(location = 2) in vec3 vertexNormal_modelspace;\n"
"\n"
"// Output data ; will be interpolated for each fragment.\n"
"out vec2 UV;\n"
"out vec3 Position_worldspace;\n"
"out vec3 Normal_cameraspace;\n"
"out vec3 EyeDirection_cameraspace;\n"
"out vec3 LightDirection_cameraspace;\n"
"\n"
"// Values that stay constant for the whole mesh.\n"
"uniform mat4 MVP;\n"
"uniform mat4 V;\n"
"uniform mat4 M;\n"
"uniform vec3 LightPosition_worldspace;\n"
"\n"
"void main(){\n"
"\n"
"\tgl_Position =  MVP * vec4(vertexPosition_modelspace,1);\n"
"\tPosition_worldspace = (M * vec4(vertexPosition_modelspace,1)).xyz;\n"
"\tvec3 vertexPosition_cameraspace = ( V * M * vec4(vertexPosition_modelspace,1)).xyz;\n"
"\tEyeDirection_cameraspace = vec3(0,0,0) - vertexPosition_cameraspace;\n"
"\tvec3 LightPosition_cameraspace = ( V * vec4(LightPosition_worldspace,1)).xyz;\n"
"\tLightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;\n"
"\tNormal_cameraspace = ( V * M * vec4(vertexNormal_modelspace,0)).xyz; // Only correct if ModelMatrix does not scale the model ! Use its inverse transpose if not.\n"
"\tUV = vertexUV;\n"
"}\n"
;


static const char standardShaderFrag[] =
"#version 330 core\n"
"\n"
"// Interpolated values from the vertex shaders\n"
"in vec2 UV;\n"
"in vec3 Position_worldspace;\n"
"in vec3 Normal_cameraspace;\n"
"in vec3 EyeDirection_cameraspace;\n"
"in vec3 LightDirection_cameraspace;\n"
"\n"
"// Ouput data\n"
"out vec3 color;\n"
"\n"
"// Values that stay constant for the whole mesh.\n"
"uniform sampler2D myTextureSampler;\n"
"uniform mat4 MV;\n"
"uniform vec3 LightPosition_worldspace;\n"
"uniform bool unlit;\n"
"\n"
"void main(){\n"
"\n"
"\tif (unlit)\n"
"\t{\n"
"\t\tcolor = texture( myTextureSampler, UV ).rgb;\n"
"\t}\n"
"\telse\n"
"\t{\n"
"\t\t// Light emission properties\n"
"\t\t// You probably want to put them as uniforms\n"
"\t\tvec3 LightColor = vec3(1,1,1);\n"
"\t\tfloat LightPower = 50.0f;\n"
"\t\t\n"
"\t\tvec3 MaterialDiffuseColor = texture( myTextureSampler, UV ).rgb;\n"
"\t\tvec3 MaterialAmbientColor = vec3(0.1,0.1,0.1) * MaterialDiffuseColor;\n"
"\t\tvec3 MaterialSpecularColor = vec3(0.3,0.3,0.3);\n"
"\t\tfloat distance = length( LightPosition_worldspace - Position_worldspace );\n"
"\t\tvec3 n = normalize( Normal_cameraspace );\n"
"\t\tvec3 l = normalize( LightDirection_cameraspace );\n"
"\t\tfloat cosTheta = clamp( dot( n,l ), 0,1 );\n"
"\t\tvec3 E = normalize(EyeDirection_cameraspace);\n"
"\t\tvec3 R = reflect(-l,n);\n"
"\t\tfloat cosAlpha = clamp( dot( E,R ), 0,1 );\n"
"\t\t\n"
"\t\tcolor = \n"
"\t\t\t// Ambient : simulates indirect lighting\n"
"\t\t\tMaterialAmbientColor +\n"
"\t\t\t// Diffuse : \"color\" of the object\n"
"\t\t\tMaterialDiffuseColor * LightColor * LightPower * cosTheta / (distance*distance) +\n"
"\t\t\t// Specular : reflective highlight, like a mirror\n"
"\t\t\tMaterialSpecularColor * LightColor * LightPower * pow(cosAlpha,5) / (distance*distance);\n"
"\t}\n"
"\n"
"}"
;


#pragma endregion

#pragma region Text Shader

static const char textShaderVert[] =
"#version 330 core\n"
"\n"
"// Input vertex data, different for all executions of this shader.\n"
"layout(location = 0) in vec2 vertexPosition_screenspace;\n"
"layout(location = 1) in vec2 vertexUV;\n"
"\n"
"// Output data ; will be interpolated for each fragment.\n"
"out vec2 UV;\n"
"\n"
"void main(){\n"
"\n"
"\t// Output position of the vertex, in clip space\n"
"\t// map [0..800][0..600] to [-1..1][-1..1]\n"
"\tvec2 vertexPosition_homoneneousspace = vertexPosition_screenspace - vec2(400,300); // [0..800][0..600] -> [-400..400][-300..300]\n"
"\tvertexPosition_homoneneousspace /= vec2(400,300);\n"
"\tgl_Position =  vec4(vertexPosition_homoneneousspace,0,1);\n"
"\t\n"
"\t// UV of the vertex flipped\n"
"\tUV = vertexUV * vec2(1.0, -1.0);\n"
"}\n"
;



static const char textShaderFrag[] =
"#version 330 core\n"
"\n"
"// Interpolated values from the vertex shaders\n"
"in vec2 UV;\n"
"\n"
"// Ouput data\n"
"out vec4 color;\n"
"\n"
"// Values that stay constant for the whole mesh.\n"
"uniform sampler2D myTextureSampler;\n"
"\n"
"void main(){\n"
"\n"
"\tcolor = texture( myTextureSampler, UV );\n"
"\t\n"
"\t\n"
"}"
;

#pragma endregion